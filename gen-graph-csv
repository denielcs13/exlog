#!/usr/bin/env python3
# vim: syntax=python ts=4 et sw=4 sts=4:

# Generates CSV files for use with gnuplot.

import argparse
import sys

import liftdb
import logparse
from common import *

# Parse arguments.
parser = argparse.ArgumentParser()
parser.add_argument('lift')
parser.add_argument('period', help='take from specified time period',
                    choices=['daily', 'weekly'])
parser.add_argument('data', help='output this on the y-axis',
                    choices=['e1rm', 'volume', 'tonnage', 'fatigue', 'repranges', 'all'])
parser.add_argument('-i', '--include-related', help='include related lifts in calculations',
                    action="store_true")
args = parser.parse_args()


#####################################################################


# Whether the lift matches the script arguments. Used for filtering.
def liftmatches(lift):
    if args.include_related and liftdb.related(args.lift, lift.name):
        return True
    return args.lift == lift.name


# Handles the case of multiple training sessions on the same day,
# but really just exists so that the code between daily/weekly
# uses the same types and the same interface.
class DailyIterator:
    def __init__(self, sessions):
        self.sessions = sessions

    def __iter__(self):
        self.idx = 0
        return self

    def __sameday(self, a, b):
        return a.toordinal() == b.toordinal()

    def __next__(self):
        if self.idx >= len(self.sessions):
            raise StopIteration

        startdate = self.sessions[self.idx].date
        acc = []
        for i in range(self.idx, len(self.sessions)):
            if self.__sameday(startdate, self.sessions[i].date):
                acc.append(self.sessions[i])
            else:
                break

        self.idx += len(acc)
        return acc


class WeeklyIterator:
    def __init__(self, sessions):
        self.sessions = sessions

    def __iter__(self):
        self.idx = 0
        return self

    # Whether the two given dates are in the same training week.
    # A training week is Sunday through Saturday (inclusive).
    def __sameweek(self, a, b):
        # Canonicalize each date according to the last Sunday.
        # isoweekday() gives 1 for Monday, 7 for Sunday.
        # So in terms of mapping how much to subtract:
        #  isoweekday -> subtract_amount
        #  [1,2,3,4,5,6,7] -> [1,2,3,4,5,6,0]
        week_a = a.toordinal() - (a.isoweekday() % 7)
        week_b = b.toordinal() - (b.isoweekday() % 7)
        return week_a == week_b

    def __next__(self):
        if self.idx >= len(self.sessions):
            raise StopIteration

        # Generate a list of sessions from here until Saturday (inclusive).
        # In terms of weekday(), Saturday is a return value of 6.
        startdate = self.sessions[self.idx].date
        acc = []

        for i in range(self.idx, len(self.sessions)):
            if self.__sameweek(startdate, self.sessions[i].date):
                acc.append(self.sessions[i])
            else:
                break

        self.idx += len(acc)
        return acc


# Return a single date as representative of the list of dates.
# For choosing a date on which to mark weekly volume, etc.
def canonical_date(sessionlist):
    return sessionlist[-1].date


def lift_e1rm(iterator):
    arr = []
    for period in iterator(sessions):
        e1rm = max([0] + list(map(lambda x: x.e1rm(liftmatches), period)))
        if e1rm > 0:
            arr.append([canonical_date(period), e1rm])
    return arr


def lift_volume(iterator):
    arr = []
    for period in iterator(sessions):
        volume = sum(s.volume(liftmatches) for s in period)
        if volume > 0:
            arr.append([canonical_date(period), volume])
    return arr


def lift_tonnage(iterator):
    arr = []
    for period in iterator(sessions):
        tonnage = sum(s.tonnage(liftmatches) for s in period)
        if tonnage > 0:
            arr.append([canonical_date(period), tonnage])
    return arr


def lift_repranges(iterator):
    arr = []
    for period in iterator(sessions):
        ranges = [0,0,0,0] # 1, 2-3, 4-6, 7+
        for session in period:
            for lift in filter(liftmatches, session.lifts):
                for set in lift.get_worksets():
                    if set.reps == 0:
                        continue
                    if set.reps == 1:
                        ranges[0] += 1
                    elif set.reps <= 3:
                        ranges[1] += 1
                    elif set.reps <= 6:
                        ranges[2] += 1
                    else:
                        ranges[3] += 1
        if sum(ranges) > 0:
            arr.append([canonical_date(period), ranges])
    return arr


def lift_fatigue(iterator):
    arr = []
    for period in WeeklyIterator(sessions):
        fatigue = 0
        for session in period:
            # This metric is a little arbitrary: total recovery needed.
            for lift in filter(liftmatches, session.lifts):
                fatigue += lift.fatigue()

        if fatigue > 0:
            arr.append([canonical_date(period), fatigue])
    return arr


#####################################################################


def print_csv(csvarr):
    for row in csvarr:
        print(', '.join(map(str, row)).replace('[','').replace(']',''))


# Given two arrays where the 0th index is the date and the rest are data,
# with both arrays sorted descending by date, make a single array that
# contains [date, ...left_data, ...right_data] for each date in dates(left,right).
def zip_csv(left, right):
    acc = []
    default = ''
    lndata = len(left[0]) - 1
    rndata = len(right[0]) - 1
    li = 0
    ri = 0
    while li < len(left) and ri < len(right):
        # Always output the greater date first. A date only occurs once.
        if left[li][0] > right[ri][0]:
            acc += [left[li] + [default for x in range(0,rndata)]]
            li += 1
        elif left[li][0] < right[ri][0]:
            acc += [[right[ri][0]] + [default for x in range(0,lndata)] + right[ri][1:]]
            ri += 1
        else:
            acc += [left[li] + right[ri][1:]]
            li += 1
            ri += 1

    while li < len(left):
        acc += [left[li] + [default for x in range(0,rndata)]]
        li += 1

    while ri < len(right):
        acc += [[right[ri][0]] + [default for x in range(0,lndata)] + right[ri][1:]]
        ri += 1

    return acc


#####################################################################


sessions = logparse.parse('exlog')

if args.period == "daily":
    iterator = DailyIterator
elif args.period == "weekly":
    iterator = WeeklyIterator

if args.data == "e1rm":
    data = lift_e1rm(iterator)
elif args.data == "volume":
    data = lift_volume(iterator)
elif args.data == "tonnage":
    data = lift_tonnage(iterator)
elif args.data == "repranges":
    data = lift_repranges(iterator)
elif args.data == "fatigue":
    data = lift_fatigue(iterator)

# Dump all of the data into one big CSV file, one column per datum.
elif args.data == "all":
    e1rm = lift_e1rm(iterator)
    volume = lift_volume(iterator)
    tonnage = lift_tonnage(iterator)
    repranges = lift_repranges(iterator)
    fatigue = lift_fatigue(iterator)

    data = e1rm
    for x in [volume, tonnage, repranges, fatigue]:
        data = zip_csv(data, x)

    # Before printing the CSV, output some variables for use by gnuplot
    # into the header. Accessible with some minor text processing.
    print("#date = 1")
    print("#e1rm = 2")
    print("#volume = 3")
    print("#tonnage = 4")
    print("#reprange1 = 5")
    print("#reprange3 = 6")
    print("#reprange5 = 7")
    print("#reprange8 = 8")
    print("#fatigue = 9")

print_csv(data)
