#!/usr/bin/env python3
# vim: syntax=python ts=4 et sw=4 sts=4:

# Generates CSV files for use with graphviz.

import argparse
import sys

import liftdb
import logparse
from common import *

# Parse arguments.
parser = argparse.ArgumentParser()
parser.add_argument('lift')
parser.add_argument('period', help='take from specified time period',
                    choices=['daily', 'weekly'])
parser.add_argument('data', help='output this on the y-axis',
                    choices=['e1rm', 'volume', 'tonnage', 'fatigue', 'repranges'])
parser.add_argument('-i', '--include-related', help='include related lifts in calculations',
                    action="store_true")
args = parser.parse_args()


if args.data == "e1rm" and args.include_related:
    sys.exit(" Error: --include-related does not make sense with e1rm.")


#####################################################################


# Whether the lift matches the script arguments. Used for filtering.
def liftmatches(lift):
    if args.include_related and liftdb.related(args.lift, lift.name):
        return True
    return args.lift == lift.name


# Handles the case of multiple training sessions on the same day,
# but really just exists so that the code between daily/weekly
# uses the same types and the same interface.
class DailyIterator:
    def __init__(self, sessions):
        self.sessions = sessions

    def __iter__(self):
        self.idx = 0
        return self

    def __sameday(self, a, b):
        return a.toordinal() == b.toordinal()

    def __next__(self):
        if self.idx >= len(self.sessions):
            raise StopIteration

        startdate = self.sessions[self.idx].date
        acc = []
        for i in range(self.idx, len(self.sessions)):
            if self.__sameday(startdate, self.sessions[i].date):
                acc.append(self.sessions[i])
            else:
                break

        self.idx += len(acc)
        return acc


class WeeklyIterator:
    def __init__(self, sessions):
        self.sessions = sessions

    def __iter__(self):
        self.idx = 0
        return self

    # Whether the two given dates are in the same training week.
    # A training week is Sunday through Saturday (inclusive).
    def __sameweek(self, a, b):
        # Canonicalize each date according to the last Sunday.
        # isoweekday() gives 1 for Monday, 7 for Sunday.
        # So in terms of mapping how much to subtract:
        #  isoweekday -> subtract_amount
        #  [1,2,3,4,5,6,7] -> [1,2,3,4,5,6,0]
        week_a = a.toordinal() - (a.isoweekday() % 7)
        week_b = b.toordinal() - (b.isoweekday() % 7)
        return week_a == week_b

    def __next__(self):
        if self.idx >= len(self.sessions):
            raise StopIteration

        # Generate a list of sessions from here until Saturday (inclusive).
        # In terms of weekday(), Saturday is a return value of 6.
        startdate = self.sessions[self.idx].date
        acc = []

        for i in range(self.idx, len(self.sessions)):
            if self.__sameweek(startdate, self.sessions[i].date):
                acc.append(self.sessions[i])
            else:
                break

        self.idx += len(acc)
        return acc


# Return a single date as representative of the list of dates.
# For choosing a date on which to mark weekly volume, etc.
def canonical_date(sessionlist):
    return sessionlist[-1].date


def lift_e1rm(iterator):
    arr = []
    for period in iterator(sessions):
        e1rm = max([0] + list(map(lambda x: x.e1rm(liftmatches), period)))
        if e1rm > 0:
            arr.append([canonical_date(period), e1rm])
    return arr


def lift_volume(iterator):
    arr = []
    for period in iterator(sessions):
        volume = sum(s.volume(liftmatches) for s in period)
        if volume > 0:
            arr.append([canonical_date(period), volume])
    return arr


def lift_tonnage(iterator):
    arr = []
    for period in iterator(sessions):
        tonnage = sum(s.tonnage(liftmatches) for s in period)
        if tonnage > 0:
            arr.append([canonical_date(period), tonnage])
    return arr


def lift_repranges(iterator):
    arr = []
    for period in iterator(sessions):
        ranges = [0,0,0,0] # 1, 2-3, 4-6, 7+
        for session in period:
            for lift in filter(liftmatches, session.lifts):
                for set in lift.get_worksets():
                    if set.reps == 0:
                        continue
                    if set.reps == 1:
                        ranges[0] += 1
                    elif set.reps <= 3:
                        ranges[1] += 1
                    elif set.reps <= 6:
                        ranges[2] += 1
                    else:
                        ranges[3] += 1
        if sum(ranges) > 0:
            arr.append([canonical_date(period), ranges])
    return arr


def lift_fatigue(iterator):
    arr = []
    for period in WeeklyIterator(sessions):
        fatigue = 0
        for session in period:
            # This metric is a little arbitrary: total recovery needed.
            for lift in filter(liftmatches, session.lifts):
                fatigue += lift.fatigue()

        if fatigue > 0:
            arr.append([canonical_date(period), fatigue])
    return arr


#####################################################################


def print_csv(csvarr):
    for row in csvarr:
        print(', '.join(map(str, row)).replace('[','').replace(']',''))


#####################################################################


sessions = logparse.parse('exlog')

if args.period == "daily":
    iterator = DailyIterator
elif args.period == "weekly":
    iterator = WeeklyIterator

if args.data == "e1rm":
    data = lift_e1rm(iterator)
elif args.data == "volume":
    data = lift_volume(iterator)
elif args.data == "tonnage":
    data = lift_tonnage(iterator)
elif args.data == "repranges":
    data = lift_repranges(iterator)
elif args.data == "fatigue":
    data = lift_fatigue(iterator)

print_csv(data)
